<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <title>Multipaint</title>
    <meta property="og:title" content="Multipaint">
    <meta property="og:url" content="https://multipaint.net">
    <meta property="og:description" content="A collaborative drawing tool.">
    <meta property="og:image" content="%PUBLIC_URL%/favicon.ico">
    <meta name="theme-color" content="rainbow">
        <style>
            /* Define rainbow gradient */
            :root {
              --rainbow: linear-gradient(to right, violet, indigo, blue, green, yellow, orange, red);
            }

            /* Apply rainbow gradient to theme-color meta tag */
            meta[name="theme-color"] {
              background: var(--rainbow); /* changed 'content' to 'background' */
            }
        
        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            width: 100%;
            background-color: #121212; /* Dark background color */
            color: #ffffff; /* Text color */
            font-family: Arial, sans-serif; /* Choose a suitable font-family */
            overflow: hidden; /* Hide vertical scrollbar */
        }
            
        #landing {
            position: absolute;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            display: none; /* Initially hide content */
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
            
        #content {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            overflow: hidden;
        }

        #settings {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        label, input, button {
            color: #ffffff; /* Text color for labels, input boxes, and buttons */
        }

        input {
            background-color: #555555; /* Darker background color for input boxes */
            padding: 8px;
            margin-bottom: 10px;
            color: #ffffff; /* Text color for input boxes */
            border: none;
            border-radius: 3px;
        }

        input[type="color"] {
            padding: 8px;
            margin-bottom: 10px;
            border: none;
            border-radius: 3px;
        }

        button {
            background-color: #4CAF50; /* Green button color */
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
        }

        button:hover {
            background-color: #45a049; /* Darker green color on hover */
        }
        
        #messages {
            height: 30vh;
            overflow-y: auto;
            margin: 10px 10px 0px 10px; /* Adjusted the left margin to 10px */
            padding: 0px;
            list-style-type: none;
            color: #ffffff;
            position: fixed;
            background-color: rgba(0, 0, 0, 0.65);
            max-width: 400px;
            word-wrap: break-word;
        }

        #form {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background-color: #333333; /* Darker background color for the message input area */
            padding: 10px;
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        #m {
            flex: 1;
            padding: 8px;
            margin-right: 10px;
            background-color: #555555; /* Darker background color for the message input box */
            color: #ffffff; /* Text color for the message input box */
            border: none;
            border-radius: 3px;
        }

        /* Set color for system messages */
        #messages li span.system {
            color: #ffffff;
        }

        /* Set color for default username */
        #messages li span.default-username {
            color: #ffffff;
        }
        
        /* Adjust the positioning of the clear canvas button */
        #clearCanvasContainer {
            left: 50%;
            transform: translateX(-50%);
        }
        
        #publicOrPrivateText {
            position: fixed;
            top: 40px;
            left: 10px;
            color: gray;
            font-weight: bold; /* Adjusted the font-weight property */
            font-size: 16px;
        }
            
        .cursor {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            position: absolute;
            /* Other styling as needed (e.g., background-color) */
        }
            
        .mode-button {
            background-color: #333;
            color: white;
            padding: 8px 12px;
            margin: 5px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
            
        .mode-button.active {
            background-color: #b3b300;
        }
                    
                    /* Canvas container to control overflow and enable scrolling */
        .canvas-container {
            overflow: hidden;
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        canvas {
            cursor: crosshair; /* Default cursor to crosshair for drawing */
            background-color: transparent;
            display: none; /* Change display to block to ensure it's visible */
            margin: auto; /* Center the canvas horizontally */
        }

        /* Adjust the cursor style based on the mode */
        .scroll-mode canvas {
            cursor: grab;
        }
                    
        .zoom-mode canvas {
            cursor: zoom-in;
        }
    </style>
</head>
<body>
    
    <div id="modeButtons">
        <!-- Draw Button with Icon -->
        <button style="position: fixed; bottom: 75px; left: 47%; z-index: 100; display: flex;" class="mode-button active" onclick="setMode('draw')">
            <i class="fas fa-pencil-alt"></i>
        </button>

        <!-- Scroll Button with Icon -->
        <button style="position: fixed; bottom: 75px; left: calc(47% + 60px); z-index: 100; display: flex;" class="mode-button" onclick="setMode('scroll')">
            <i class="fas fa-hand-paper"></i>
        </button>
    </div>
    <div class="canvas-container">
        <canvas id="canvas" width="100%" height="100%"></canvas>
    </div>
    
    <div id="landing" style="text-align: center; top: 25%;">
        <a href="https://www.buymeacoffee.com/multipaint"><button id="donateButton" style="position: fixed; top: 10px; right: 10px; background-color: #6772e5; color: #fff; font-size: 1em; padding: 8px 15px; border: none; border-radius: 5px; cursor: pointer; display: flex;">Donate</button></a>
        <a href="/privacy"><button id="privacyButton" style="position: fixed; top: 50px; right: 10px; background-color: #6772e5; color: #fff; font-size: 1em; padding: 8px 15px; border: none; border-radius: 5px; cursor: pointer; display: flex;">Privacy Policy</button></a>
        <h1 style="font-size: 2.5em; margin-bottom: 10px; display: flex; justify-content: center;">
            <form id="form" action="">
                <div id="card-element"></div>
                <div id="card-errors" role="alert"></div>
            </form>
            <span style="color: #FF0000;">M</span>
            <span style="color: #FF7F00;">u</span>
            <span style="color: #FFFF00;">l</span>
            <span style="color: #00FF00;">t</span>
            <span style="color: #0000FF;">i</span>
            <span style="color: #4B0082;">p</span>
            <span style="color: #9400D3;">a</span>
            <span style="color: #FF0000;">i</span>
            <span style="color: #FF7F00;">n</span>
            <span style="color: #FFFF00;">t</span>
        </h1>
        <p style="color: #cccccc; font-size: 1.2em; margin-bottom: 20px;">Create or Join a Room</p>
        <label for="roomCode" style="color: #ffffff; font-size: 1.2em;">Enter Room Code:</label>
        <div style="display: flex; align-items: center; justify-content: center; flex-direction: column; margin-bottom: 20px;">
            <input id="roomCode" onkeyup="handleKeyUp(event)" style="padding: 8px; font-size: 1em; border: 1px solid #555555; border-radius: 3px; margin-bottom: 10px; display: flex;" />
            <button onclick="joinRoom()" style="background-color: #4CAF50; color: #ffffff; font-size: 1em; padding: 8px 15px; border: none; border-radius: 5px; cursor: pointer; display: flex;">Join Room</button>
            <button onclick="generateAndJoinRoom()" style="background-color: #4CAF50; color: #ffffff; font-size: 1em; padding: 8px 15px; border: none; border-radius: 5px; cursor: pointer; display: flex; margin-top: 10px;">Generate Random Room</button>
            <button onclick="joinRandomRoom()" style="background-color: #4CAF50; color: #ffffff; font-size: 1em; padding: 8px 15px; border: none; border-radius: 5px; cursor: pointer; display: flex; margin-top: 10px;">Join Random Room</button>
        </div>
    </div>
    
    <div id="content">
    <div id="settings" style="position: fixed; top: 50%; left: 50%; transform: translate(-50%,-50%);">
        <label for="username">Username:</label>
        <input id="username" autocomplete="off" value="" maxlength="30" />
        <label for="color">Color:</label>
        <input id="color" type="color" value="#ffffff" />
        <button id="updateSettings" onclick="updateSettings()">Join Room</button>
    </div>
    
    <label htmlFor="publicToggle" id="publicToggleLabel" style="position: fixed; top: 40px; left: 10px; display: none;">Public Room:</label>
    <input type="checkbox" id="publicToggle" style="position: fixed; top: 40px; left: 110px; display: none;"/>
    <div id="publicOrPrivateText" style="position: fixed; top: 40px; left: 10px; display: show;"></div>

    <div id="activeUsersCount" style="position: fixed; top: 10px; left: 10px; color: #ffffff;"></div>
    <button id="toggleChatButton" onclick="toggleChat()" style="position: fixed; top: 40px; left: 10px; margin-top: 35vh;">Toggle Chat</button>
    
    <div id="messages" style="flex: 1; position: fixed; flex-direction: column; align-items: flex-start; margin-left: 0px; margin-top: -30px; left: 0%; top: 10%;">
    </div>
    
    <div id="clearCanvasContainer" style="position: fixed; top: 10px; left: 50%; transform: translateX(-50%);">
            <button id="clearCanvasButton" onclick="clearCanvas()">Clear Canvas</button>
        </div>
    
    <button id="saveCanvasButton" onclick="saveCanvasImage()" style="position: fixed; top: 10px; right: 10px; background-color: #4CAF50; color: #ffffff; font-size: 1em; padding: 8px 15px; border: none; border-radius: 5px; cursor: pointer; display: flex;">Save Image</button>
    <button style="position: fixed; top: 50px; right: 10px; background-color: #4CAF50; color: #ffffff; font-size: 1em; padding: 8px 15px; border: none; border-radius: 5px; cursor: pointer; display: flex;" onclick="window.location.href='/'">Back to Menu</button>
    
    <button id="undoButton" style="position: fixed; bottom: 75px; left: 10px; background-color: #6772e5; color: #ffffff; font-size: 1em; padding: 8px 15px; border: none; border-radius: 5px; cursor: pointer; display: flex;" onclick="undo();">Undo</button>
    <button id="redoButton" style="position: fixed; bottom: 75px; left: 85px; background-color: #6772e5; color: #ffffff; font-size: 1em; padding: 8px 15px; border: none; border-radius: 5px; cursor: pointer; display: flex;" onclick="redo();">Redo</button>
    
    <form id="form" action="">
        <input id="m" autocomplete="off" maxlength="300" /><button id="m-button">Send</button>
    </form>
    </div>

    <script src="https://code.jquery.com/jquery-3.6.4.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css">

    <script>
        const socket = io();

        const room = window.location.pathname.slice(1);
        let username = '';
        let color = '';
        let activeRooms = {};  // Initialize activeRooms as an empty object
        let activeRoomsVar = [];  // Initialize activeRooms as an empty object
        //const drawingHistory = {};
        let lastPositions = {};
        let drawingHistory = []; // Stores the drawing actions
        let redoStack = []; // Stores actions for redo
        let cursors = {}; // Object to track cursors of other users
        
        let lastServerX, lastServerY;
        
        function setCookie(name, value, days) {
            const expires = new Date();
            expires.setTime(expires.getTime() + days * 24 * 60 * 60 * 1000);
            document.cookie = `${name}=${value};expires=${expires.toUTCString()};path=/`;
        }
        
        function getCookie(name) {
            const keyValue = document.cookie.match(`(^|;) ?${name}=([^;]*)(;|$)`);
            return keyValue ? keyValue[2] : null;
        }

        function joinRoom() {
            const roomCode = $('#roomCode').val().trim();
            if (roomCode) {
                // Redirect to the room-specific URL
                window.location.href = `/${roomCode}`;
            }
        }

        function handleKeyUp(event) {
            if (event.key === 'Enter') {
                joinRoom();
            }
        }

        // Check if there is a room code in the URL
        const roomCodeInUrl = window.location.pathname.slice(1);
        if (roomCodeInUrl) {
            // Room code is present, show chat content
            $('#content').show();
            $('#landing').hide();
            $('#toggleChatButton').hide();
            $("#undoButton").hide();
            $("#redoButton").hide();
            $("#modeButtons").hide();
            $('#m').hide();
            $('#m-button').hide();
            $('#clearCanvasButton').hide();
            document.title = roomCodeInUrl;

            // Load username and color from cookies
            const savedUsername = getCookie('username');
            const savedColor = getCookie('color');

            if (savedUsername) {
                // Check if the saved username is "Guest"
                if (savedUsername === "Guest") {
                    // If the saved username is "Guest", set the input value to blank
                    $('#username').val("");
                } else {
                    // If the saved username is not "Guest", set the input value to the saved username
                    $('#username').val(savedUsername);
                }
            }

            if (savedColor) {
                $('#color').val(savedColor);
            }

            // Update settings with loaded values
            // updateSettings();
        } else {
            // Room code is not present, show landing page
            $('#landing').show();
            $('#content').hide();
            $("#canvas").hide();
            $("#modeButtons").hide();
        }
        // Enable message input and button after updating settings
        const enableMessageInput = () => {
            $('#form').prop('disabled', false);
            $('form button').prop('disabled', false);
        };
        
        // Function to handle restoring canvas data
        const restoreCanvas = () => {
            // Your logic for restoring canvas data goes here
            // For example, you might want to emit the 'restoreCanvas' event to the server
            // with the appropriate data, and handle it on the server-side
            socket.emit('restoreCanvas', { ctx });
        };

        const updateSettings = () => {
            username = $('#username').val() || 'Guest';
            color = $('#color').val() || '#ffffff';

            // Set cookies for username and color
            setCookie('username', username, 365);
            setCookie('color', color, 365);

            // Emit user information to the server
            socket.emit('join', { room, username, color });

            // Call restoreCanvas immediately after emitting the join event
            restoreCanvas();

            // Hide settings
            $('#settings').hide();
            $('#canvas').show();
            $('#toggleChatButton').show();
            $('#modeButtons').show();
            $('#toggleChatButton').show();
            // $('#undoButton').show();
            // $('#redoButton').show();
            $('#m').show();
            $('#m-button').show();
            $('#clearCanvasButton').show();
            
            $('#messages').width("400px");
            $('#messages').css('padding', '10px');
            
            // Enable message input and button
            enableMessageInput();
        };

        const sendMessage = (messageType, data) => {
            // Include username and color in the message data
            socket.emit(messageType, { room, username, color, ...data });

            // Clear the input field
            $('#m').val('');
        };

        $('form').submit(function () {
            sendMessage('message', { message: $('#m').val().trim() });
            return false;
        });

        // Event listener for the Enter key press in the username input
        $('#username').on('keyup', function (event) {
            if (event.key === 'Enter') {
                updateSettings();
            }
        });

        socket.on('message', function (data) {
            // Display messages with usernames and colors
            const message = `<span style="color: ${data.color}">${data.username}:</span> ${data.message}`;
            appendMessage(message);
        });

        // Add this block to your existing script
        let canvas, ctx, drawing, lastX, lastY;

        $(document).ready(function () {
            // Get the canvas and its 2d context
            canvas = document.getElementById('canvas');
            ctx = canvas.getContext('2d');

            // Set canvas dimensions relative to the viewport
            canvas.width = window.innerWidth * 1.1; // 90% of the viewport width
            canvas.height = window.innerHeight * 1.1; // 90% of the viewport height
            
            $('#publicToggleLabel').hide();
            $('#publicToggle').hide();

            // Initialize drawing variables
            drawing = false;
            lastX = 0;
            lastY = 0;

            // Add mouse event listeners to the canvas
            canvas.addEventListener('mousedown', startDrawing);
            canvas.addEventListener('mousemove', draw);
            canvas.addEventListener('mouseup', stopDrawing);
            canvas.addEventListener('mouseout', stopDrawing);
            
            canvas.addEventListener('touchstart', handleTouchStart);
            canvas.addEventListener('touchmove', handleTouchMove);
            canvas.addEventListener('touchend', handleTouchEnd);
            
            canvas.addEventListener('mousemove', (event) => {
                const rect = canvas.getBoundingClientRect();
                const x = event.clientX - rect.left;
                const y = event.clientY - rect.top;
                socket.emit('cursorMove', { room, userId: socket.id, position: { x, y } });
            });
            
            toggleChat();
        });
        
        let mode = 'draw'; // Default mode

        // Modify the startDrawing function
            function startDrawing(e) {
                if (mode !== 'draw') return;
                const rect = canvas.getBoundingClientRect();
                drawing = true;
                lastX = e.clientX - rect.left;
                lastY = e.clientY - rect.top;

                // Store the starting point of the drawing for the current user
                drawingHistory[username] = [{ x: lastX, y: lastY }];

                // Emit the 'drawingStart' event with room and start coordinates
                socket.emit('drawingStart', { room, startX: lastX, startY: lastY, userId: socket.id });
            }

            // Modify the draw function
            function draw(e) {
                if (mode !== 'draw') return;
                if (!drawing) return;
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                ctx.beginPath();

                // Get the drawing path specific to the current user
                const path = drawingHistory[username];

                // Draw from the last point in the path to the current point
                ctx.moveTo(path[path.length - 1].x, path[path.length - 1].y);
                ctx.lineTo(x, y);
                ctx.stroke();

                // Update the last point in the path
                path.push({ x, y });

                if (drawing) {
                    socket.emit('drawing', { room, x, y, color, userId: socket.id });
                }
            }

            // Modify the stopDrawing function
            function stopDrawing() {
                if (mode !== 'draw') return;
                if (!drawing) return;
                drawing = false;

                // Clear the drawing history for the current user when drawing stops
                delete drawingHistory[username];

                // Emit the 'drawingEnd' event with room information
                if (drawing) {
                    socket.emit('drawingEnd', { room, userId: socket.id });
                    drawing = false;
                }
            }
        
        // Variables to store touch start coordinates
        let touchStartX, touchStartY;

        function handleTouchStart(e) {
            if (mode !== 'draw') return;
            e.preventDefault(); // Prevent scrolling when touching the canvas
            const touch = e.touches[0]; // Get the first touch event
            const rect = canvas.getBoundingClientRect(); // Get the canvas position and size
            drawing = true; // Set drawing to true
            lastX = touch.clientX - rect.left; // Calculate the X position relative to the canvas
            lastY = touch.clientY - rect.top; // Calculate the Y position relative to the canvas

            // Similar to the mouse start, we can emit the drawingStart event
            sendMessage('drawingStart', { startX: lastX, startY: lastY });
        }

        function handleTouchMove(e) {
            if (mode !== 'draw') return;
            if (!drawing) return; // If we are not drawing, exit the function
            e.preventDefault(); // Prevent scrolling when touching the canvas
            const touch = e.touches[0]; // Get the first touch event
            const rect = canvas.getBoundingClientRect(); // Get the canvas position and size
            const x = touch.clientX - rect.left; // Calculate the X position relative to the canvas
            const y = touch.clientY - rect.top; // Calculate the Y position relative to the canvas

            // Drawing logic
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(lastX, lastY); // Move to the last position
            ctx.lineTo(x, y); // Draw a line to the new position
            ctx.stroke();

            // Update the last position for the next movement
            lastX = x;
            lastY = y;

            // Emit the drawing data to other users
            sendMessage('drawing', { x, y, color });
        }

        function handleTouchEnd(e) {
            if (mode !== 'draw') return;
            e.preventDefault(); // Prevent additional actions on touch end
            if (!drawing) return; // If we are not drawing, exit the function
            drawing = false; // Stop drawing

            // Emit the drawingEnd event
            sendMessage('drawingEnd', {});
        }
        
        // Function to clear drawing history when the canvas is cleared
        function clearCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Clear drawing history for all users
            for (const user in drawingHistory) {
                delete drawingHistory[user];
            }

            sendMessage('clearCanvas', {});
        }

        // Function to append messages and drawings to the messages container
        function appendMessage(message) {
            // Append the new message
            const newMessage = $('<li>').html(message);
            const messagesContainer = $('#messages');

            // Append the new message and remove the oldest if needed
            messagesContainer.append(newMessage);

            // Scroll messages up when a new message is added
            messagesContainer.scrollTop(messagesContainer.prop('scrollHeight'));
        }
        
        // Initialize an object to hold drawing histories for each user
        let userDrawingHistories = {};

        function drawFromServer(data) {
            const userId = data.userId; // Unique identifier for the user

            // Ensure userDrawingHistories is properly initialized for this user
            if (!userDrawingHistories[userId]) {
                userDrawingHistories[userId] = [];
            }

            const userHistory = userDrawingHistories[userId];

            // Guard against attempting to access or modify a path before it's initialized
            if (data.isStart) {
                // Initialize a new path at the start
                userHistory.push([{ x: data.x, y: data.y }]);
            } else {
                // Ensure there's at least one path initialized before trying to add points or mark the end
                if (userHistory.length === 0) {
                    // Optionally handle the error, e.g., by initializing a path or logging a warning
                    console.warn("Attempting to draw or end a line before starting it. Initializing a new path.");
                    userHistory.push([{ x: data.x, y: data.y }]); // Initialize a path if desired
                } else {
                    // Normal operation for adding points to the existing path or marking its end
                    if (data.isEnd) {
                        userHistory[userHistory.length - 1].push({ x: data.x, y: data.y });
                        // console.log("This is the end.");
                    } else {
                        userHistory[userHistory.length - 1].push({ x: data.x, y: data.y });

                        // Draw the line segment
                        const lastPoint = userHistory[userHistory.length - 1].slice(-2);
                        ctx.beginPath();
                        ctx.moveTo(lastPoint[0].x, lastPoint[0].y);
                        ctx.lineTo(lastPoint[1].x, lastPoint[1].y);
                        ctx.strokeStyle = data.color;
                        ctx.lineWidth = 2;
                        ctx.stroke();
                    }
                }
            }
        }

        // Ensure that the 'drawing', 'drawingStart', and 'drawingEnd' event handlers
        // send the isStart and isEnd flags appropriately
        socket.on('drawing', function(data) {
            drawFromServer({ ...data, isStart: false, isEnd: false });
        });
        socket.on('drawingStart', function(data) {
            drawFromServer({ ...data, isStart: true });
        });
        socket.on('drawingEnd', function(data) {
            drawFromServer({ ...data, isEnd: true });
        });

        socket.on('clearCanvas', function () {
            // Clear the canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        });

        // Modify the socket.on('userJoin') function to check if the user is the least-recently-joined user
        socket.on('userJoin', function (data) {
            // Increment the user count for the joined room
            activeRooms[data.room] = (activeRooms[data.room] || 0) + 1;

            // Emit the updated user count to all clients in the room
            io.to(data.room).emit('activeUsersCount', { room: data.room, count: activeRooms[data.room] });

            // Store the timestamp of the most recent user join event
            const currentTime = new Date().getTime();
            if (currentTime > mostRecentUserJoinTimestamp) {
                mostRecentUserJoinTimestamp = currentTime;
                mostRecentUser = data.username;
                isLeastRecentUser = true; // Update the variable to indicate that the user is the least-recently-joined user
            } else {
                isLeastRecentUser = false; // Reset the variable if the user is not the least-recently-joined user
            }

            // Check if there were previously no users in the room
            if (activeRooms[data.room] === 1) {
                isFirstUser = true;
                // Send a message to the chat box indicating that this is the first user
                io.to(data.room).emit('message', {
                    username: 'System',
                    color: '#ffffff',
                    message: `${data.username} is the first user in the room.`
                });
            }
        });
        
        socket.on('userLeave', function (data) {
            // Decrement the user count for the left room
            if (activeRooms[data.room] > 0) {
                activeRooms[data.room]--;

                // Emit the updated user count to all clients in the room
                io.to(data.room).emit('activeUsersCount', { room: data.room, count: activeRooms[data.room] });

                // Check if the leaving user is the first user
                if (data.username === mostRecentUser) {
                    // Find the new earliest join timestamp and corresponding username
                    let earliestJoinTimestamp = Infinity;
                    let newFirstUser = '';
                    for (const [user, joinTime] of Object.entries(activeUsers)) {
                        if (joinTime < earliestJoinTimestamp) {
                            earliestJoinTimestamp = joinTime;
                            newFirstUser = user;
                        }
                    }
                    
                    const cursor = document.getElementById(`cursor-${data.userId}`);
                    
                    if (cursor) {
                        cursor.parentNode.removeChild(cursor);
                    }
                    
                    // Update the first user's information
                    firstUserJoinTimestamp = earliestJoinTimestamp;
                    firstUser = newFirstUser;

                    // Print the updated result
                    console.log(`The first person to join the room is now: ${firstUser}`);
                }
            }

            // Check if there are no users left in the room
            if (activeRooms[data.room] === 0) {
                // Clear the first user information
                firstUserJoinTimestamp = 0;
                firstUser = '';

                // Print a message indicating that there are no users in the room
                console.log('No users left in the room.');
            }
        });
    
    // Add this block to your existing script
    socket.on('activeRooms', function (data) {
        activeRooms = data.activeRooms; // Update the local activeRooms variable.
        activeRoomsVar = activeRooms;
    });
        
        socket.on('connection', function (socket) {
            // Broadcast active user count to the new user
            socket.on('activeUsersCount', function (data) {
                io.to(socket.id).emit('activeUsersCount', { room: data.room, count: activeRooms[data.room] });
            });
        });

        // Function to get the list of active rooms
        function getActiveRooms() {
            const activeRoomList = Object.keys(activeRooms).filter((room) => activeRooms[room] > 0);
            return activeRoomList;
        }

        function joinRandomRoom() {
            // Get the list of active rooms
            const activeRoomList = activeRooms;

            // Check if there are active rooms
            if (activeRoomList.length > 0) {
                // Randomly select a room from the list
                const randomRoom = activeRoomList[Math.floor(Math.random() * activeRoomList.length)];

                // Debugging: Log the randomly selected room to the console
                console.log('Random Room:', randomRoom);

                // Redirect to the selected room-specific URL
                window.location.href = `/${randomRoom}`;
                
                // Emit the updated user count to all clients in the room
                io.to(data.room).emit('activeUsersCount', { room: data.room, count: activeRooms[data.room] });
            } else {
                // Debugging: Alert the current state of activeRooms
                alert("No active rooms available. Create or join a room manually.");
            }
        }
        
        //Function to save the canvas image
        const saveCanvasImage = () => {
            const canvas = document.getElementById('canvas');
            const dataUrl = canvas.toDataURL(); // Get the data URL of the canvas image
            const a = document.createElement('a');
            a.href = dataUrl;
            a.download = 'image.png';
            a.click();
        };
        
        function generateAndJoinRoom() {
            const generatedRoomCode = generateRandomRoomCode();
            window.location.href = `/${generatedRoomCode}`;
        }

        function generateRandomRoomCode() {
            const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
            const codeLength = 6; // Adjust the length of the generated room code if needed
            let roomCode = '';

            do {
                // Generate a random room code
                roomCode = '';
                for (let i = 0; i < codeLength; i++) {
                    const randomIndex = Math.floor(Math.random() * characters.length);
                    roomCode += characters.charAt(randomIndex);
                }
            } while (activeRooms.hasOwnProperty(roomCode)); // Check if the code already exists in activeRooms

            return roomCode;
        }
        
        socket.on('activeUsersCount', function (data) {
               // Update the active user count in the UI
               updateActiveUsersCount(data.count);
           });

        // Function to update the active user count in the UI
        function updateActiveUsersCount(count) {
            const activeUsersCountElement = $('#activeUsersCount');
            activeUsersCountElement.text(`Active Users: ${count}`);
        }
        
        function toggleChat() {
            const messages = document.getElementById('messages');
            const toggleChatButton = document.getElementById('toggleChatButton');

            if (messages.style.display === 'none' || messages.style.display === '') {
                messages.style.display = 'block';
                toggleChatButton.style.marginTop = '35vh';
                toggleChatButton.textContent = 'Close Chat'; // Change button text to "Close Chat"
            } else {
                messages.style.display = 'none';
                toggleChatButton.style.marginTop = '5vh';
                toggleChatButton.textContent = 'Open Chat'; // Change button text to "Open Chat"
            }
        }

        // Function to show chat content and toggle button
        function showChat() {
            const content = document.getElementById('content');
            const button = document.getElementById('toggleChatButton');

            $('#m').show();
                   
            //button.style.display = 'block'; // Show the toggle button
            button.textContent = 'Close Chat';
        }

        // Function to hide chat content and toggle button
        function hideChat() {
            const content = document.getElementById('content');
            const button = document.getElementById('toggleChatButton');

            $('#m').hide();
        }
        
        // Update the function to show public/private text instead of the toggle button
        function updatePublicOrPrivateText(isPublic) {
            const publicOrPrivateText = document.getElementById('publicOrPrivateText');
            
            if (isPublic) {
                publicOrPrivateText.textContent = 'Public Room'; // Display text for public room
            } else {
                publicOrPrivateText.textContent = 'Private Room'; // Display text for private room
            }
            
            publicOrPrivateText.style.display = 'block'; // Show the text
        }
        
        // Redraw the canvas based on the current state of drawingHistory
        function redrawCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear the canvas
            // Iterate over drawingHistory and redraw each action
            drawingHistory.forEach(action => {
                // Redrawing logic based on the action type
                // For example, you might have action types like 'line' with start and end coordinates
            });
        }
        
        /*
        socket.on('cursorMove', (data) => {
            let cursor = cursors[data.userId];
            if (!cursor) {
                // Create a new cursor element if it doesn't exist
                cursor = document.createElement('div');
                cursor.classList.add('cursor');
                cursor.setAttribute('id', `cursor-${data.userId}`);
                cursor.style.position = 'absolute';
                cursor.style.width = '10px';
                cursor.style.height = '10px';
                cursor.style.borderRadius = '50%'; // Makes the cursor a circle
                cursor.style.pointerEvents = 'none'; // Ensures the cursor doesn't interfere with canvas drawing
                document.body.appendChild(cursor);
                cursors[data.userId] = cursor;
            }
            
            // Get the canvas and its 2d context
            canvas = document.getElementById('canvas');
            ctx = canvas.getContext('2d');
            // Calculate the position relative to the canvas or a specific container
            const rect = canvas.getBoundingClientRect(); // Adjust this if the cursor should align with another element

            cursor.style.left = `${data.position.x - rect.left - cursor.offsetWidth / 2 - 150}px`;
            cursor.style.top = `${data.position.y - rect.top - cursor.offsetHeight / 2}px`;
            
            cursor.style.marginLeft = "0px;";
            // Set the cursor's color
            cursor.style.backgroundColor = data.color;
        });
         */
        
        function undo() {
            socket.emit('undo', { room: room, userId: socket.id });
        }
        
        socket.on('undo', function(data) {
            // Assuming drawingHistory is an array of drawing actions
            // Remove the last action
            drawingHistory.pop();

            // Clear the canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Redraw all remaining actions
            drawingHistory.forEach(function(action) {
                // Redraw action here
                redrawAction(action);
            });
        });

        function redrawAction(action) {
            // Assuming a simple line drawing action for the example
            ctx.beginPath();
            ctx.moveTo(action.startX, action.startY);
            ctx.lineTo(action.x, action.y);
            ctx.strokeStyle = action.color;
            ctx.lineWidth = 2; // Example line width
            ctx.stroke();
        }

        function redo() {
            socket.emit('redo', { room: room, userId: socket.id });
        }
        
        // Additional script for modes

                // Implement scrolling functionality
                document.querySelector('.canvas-container').addEventListener('mousedown', function(e) {
                    
                    if (mode === 'draw') {
                            e.preventDefault(); // Prevent the browser's default action to allow drawing
                            draw(e.touches[0]); // Adapt draw function for touch events
                        }
                    
                    if (mode !== 'scroll') return;
                    const container = this;
                    let startX = e.pageX - container.offsetLeft;
                    let startY = e.pageY - container.offsetTop;
                    let scrollLeft = container.scrollLeft;
                    let scrollTop = container.scrollTop;

                    function onMouseMove(e) {
                        // Calculate the distance moved
                        const dx = e.pageX - container.offsetLeft - startX;
                        const dy = e.pageY - container.offsetTop - startY;
                        container.scrollLeft = scrollLeft - dx;
                        container.scrollTop = scrollTop - dy;
                    }

                    function onMouseUp() {
                        document.removeEventListener('mousemove', onMouseMove);
                        document.removeEventListener('mouseup', onMouseUp);
                    }

                    document.addEventListener('mousemove', onMouseMove);
                    document.addEventListener('mouseup', onMouseUp);
                },  { passive: false });

                // Implement zoom functionality
                document.getElementById('canvas').addEventListener('wheel', function(e) {
                    if (mode !== 'zoom') return;
                    e.preventDefault(); // Prevent the default scroll behavior
                    const scaleAmount = e.deltaY * -0.01;
                    // Apply zooming logic here, e.g., adjusting canvas size or using transform: scale(...)
                });
        
        function setMode(newMode) {
            mode = newMode;
            
            // First, remove 'active' class from all mode buttons
            document.querySelectorAll('.mode-button').forEach(button => {
                button.classList.remove('active');
            });
            
            // Then, add 'active' class to the button that was clicked based on the mode
            // This assumes the mode names directly correlate with the class names of the icons
            if(newMode === 'draw') {
                document.querySelector('.mode-button[onclick="setMode(\'draw\')"]').classList.add('active');
            } else if(newMode === 'scroll') {
                document.querySelector('.mode-button[onclick="setMode(\'scroll\')"]').classList.add('active');
            } // Add more conditions if you have more modes

            // Additional logic to apply the mode (e.g., changing cursor style)
            const canvasContainer = document.querySelector('.canvas-container');
            if(canvasContainer) {
                canvasContainer.className = `canvas-container ${newMode}-mode`; // Apply the mode as a class to the container
            }
        }
    </script>
</body>
</html>
