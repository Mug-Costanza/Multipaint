<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <title>Multipaint</title>
    <meta content="Multipaint" property="og:title" />
    <meta content="A collaborative drawing tool." property="og:description" />
    <meta content="https://multipaint.net" property="og:url" />
    <meta content="%PUBLIC_URL%/favicon.ico" property="og:image" />
    <meta content="rainbow" name="theme-color" />
    <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />

    <style>
        /* Define rainbow gradient */
        :root {
          --rainbow: linear-gradient(to right, violet, indigo, blue, green, yellow, orange, red);
        }

        /* Apply rainbow gradient to theme-color meta tag */
        meta[name="theme-color"] {
          content: var(--rainbow);
        }
        
        body {
            background-color: #121212; /* Dark background color */
            color: #ffffff; /* Text color */
            font-family: Arial, sans-serif; /* Choose a suitable font-family */
            margin: 0;
            padding: 0;
            height: 100vh; /* Set the body height to full viewport height */
            overflow: hidden; /* Hide vertical scrollbar */
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0;
            padding: 0;
            overflow: hidden;
            position: relative;
        }
        
        #canvas {
            display: none; /* Change display to block to ensure it's visible */
            margin: auto; /* Center the canvas horizontally */
        }

        #content {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            overflow: hidden;
        }

        #settings {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        label, input, button {
            color: #ffffff; /* Text color for labels, input boxes, and buttons */
        }

        input {
            background-color: #555555; /* Darker background color for input boxes */
            padding: 8px;
            margin-bottom: 10px;
            color: #ffffff; /* Text color for input boxes */
            border: none;
            border-radius: 3px;
        }

        input[type="color"] {
            padding: 8px;
            margin-bottom: 10px;
            border: none;
            border-radius: 3px;
        }

        button {
            background-color: #4CAF50; /* Green button color */
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
        }

        button:hover {
            background-color: #45a049; /* Darker green color on hover */
        }
        
        #messages {
            height: 30vh;
            overflow-y: auto;
            margin: 10px 10px 0px 10px; /* Adjusted the left margin to 10px */
            padding: 0px;
            list-style-type: none;
            color: #ffffff;
            position: fixed;
            background-color: rgba(0, 0, 0, 0.65);
            max-width: 400px;
            word-wrap: break-word;
        }

        #form {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background-color: #333333; /* Darker background color for the message input area */
            padding: 10px;
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        #m {
            flex: 1;
            padding: 8px;
            margin-right: 10px;
            background-color: #555555; /* Darker background color for the message input box */
            color: #ffffff; /* Text color for the message input box */
            border: none;
            border-radius: 3px;
        }

        /* Set color for system messages */
        #messages li span.system {
            color: #ffffff;
        }

        /* Set color for default username */
        #messages li span.default-username {
            color: #ffffff;
        }
        
        /* Adjust the positioning of the clear canvas button */
        #clearCanvasContainer {
            left: 50%;
            transform: translateX(-50%);
        }
        
        #publicOrPrivateText {
            position: fixed;
            top: 40px;
            left: 10px;
            color: gray;
            font-weight: bold; /* Adjusted the font-weight property */
            font-size: 16px;
        }
    </style>
</head>
<body>
    <canvas id="canvas" width="110%" height="110%"></canvas>
    
    <div id="landing" style="text-align: center; margin-top: 50px;">
        <a href="https://www.buymeacoffee.com/multipaint"><button id="donateButton" style="position: fixed; top: 10px; right: 10px; background-color: #6772e5; color: #fff; font-size: 1em; padding: 8px 15px; border: none; border-radius: 5px; cursor: pointer; display: flex;">Donate</button></a>
        <a href="/privacy"><button id="privacyButton" style="position: fixed; top: 50px; right: 10px; background-color: #6772e5; color: #fff; font-size: 1em; padding: 8px 15px; border: none; border-radius: 5px; cursor: pointer; display: flex;">Privacy Policy</button></a>
        <h1 style="font-size: 2.5em; margin-bottom: 10px; display: flex; justify-content: center;">
            <form id="form" action="">
                <div id="card-element"></div>
                <div id="card-errors" role="alert"></div>
            </form>
            <span style="color: #FF0000;">M</span>
            <span style="color: #FF7F00;">u</span>
            <span style="color: #FFFF00;">l</span>
            <span style="color: #00FF00;">t</span>
            <span style="color: #0000FF;">i</span>
            <span style="color: #4B0082;">p</span>
            <span style="color: #9400D3;">a</span>
            <span style="color: #FF0000;">i</span>
            <span style="color: #FF7F00;">n</span>
            <span style="color: #FFFF00;">t</span>
        </h1>
        <p style="color: #cccccc; font-size: 1.2em; margin-bottom: 20px;">Create or Join a Room</p>
        <label for="roomCode" style="color: #ffffff; font-size: 1.2em;">Enter Room Code:</label>
        <div style="display: flex; align-items: center; justify-content: center; flex-direction: column; margin-bottom: 20px;">
            <input id="roomCode" onkeyup="handleKeyUp(event)" style="padding: 8px; font-size: 1em; border: 1px solid #555555; border-radius: 3px; margin-bottom: 10px; display: flex;" />
            <button onclick="joinRoom()" style="background-color: #4CAF50; color: #ffffff; font-size: 1em; padding: 8px 15px; border: none; border-radius: 5px; cursor: pointer; display: flex;">Join Room</button>
            <button onclick="generateAndJoinRoom()" style="background-color: #4CAF50; color: #ffffff; font-size: 1em; padding: 8px 15px; border: none; border-radius: 5px; cursor: pointer; display: flex; margin-top: 10px;">Generate Random Room</button>
            <button onclick="joinRandomRoom()" style="background-color: #4CAF50; color: #ffffff; font-size: 1em; padding: 8px 15px; border: none; border-radius: 5px; cursor: pointer; display: flex; margin-top: 10px;">Join Random Room</button>
        </div>
    </div>
    
    <div id="content">
    <div id="settings" style="position: fixed; top: 50%; left: 50%; transform: translate(-50%,-50%);">
        <label for="username">Username:</label>
        <input id="username" autocomplete="off" value="" maxlength="30" />
        <label for="color">Color:</label>
        <input id="color" type="color" value="#ffffff" />
        <button id="updateSettings" onclick="updateSettings()">Join Room</button>
    </div>
    
    <label htmlFor="publicToggle" id="publicToggleLabel" style="position: fixed; top: 40px; left: 10px; display: none;">Public Room:</label>
    <input type="checkbox" id="publicToggle" style="position: fixed; top: 40px; left: 110px; display: none;"/>
    <div id="publicOrPrivateText" style="position: fixed; top: 40px; left: 10px; display: show;"></div>

    <div id="activeUsersCount" style="position: fixed; top: 10px; left: 10px; color: #ffffff;"></div>
    <button id="toggleChatButton" onclick="toggleChat()" style="position: fixed; top: 40px; left: 10px; margin-top: 35vh;">Toggle Chat</button>
    
    <div id="messages" style="flex: 1; position: fixed; flex-direction: column; align-items: flex-start; margin-left: 0px; margin-top: -30px; left: 0%; top: 10%;">
    </div>
    
    <div id="clearCanvasContainer" style="position: fixed; top: 10px; left: 50%; transform: translateX(-50%);">
            <button id="clearCanvasButton" onclick="clearCanvas()">Clear Canvas</button>
        </div>
    
    <button id="saveCanvasButton" onclick="saveCanvasImage()" style="position: fixed; top: 10px; right: 10px; background-color: #4CAF50; color: #ffffff; font-size: 1em; padding: 8px 15px; border: none; border-radius: 5px; cursor: pointer; display: flex;">Save Image</button>
    <button style="position: fixed; top: 50px; right: 10px; background-color: #4CAF50; color: #ffffff; font-size: 1em; padding: 8px 15px; border: none; border-radius: 5px; cursor: pointer; display: flex;" onclick="window.location.href='/'">Back to Menu</button>
    
    <form id="form" action="">
        <input id="m" autocomplete="off" maxlength="300" /><button>Send</button>
    </form>
    </div>

    <script src="https://code.jquery.com/jquery-3.6.4.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js"></script>

    <script>
        const socket = io();

        const room = window.location.pathname.slice(1);
        let username = '';
        let color = '';
        let activeRooms = {};  // Initialize activeRooms as an empty object
        let activeRoomsVar = [];  // Initialize activeRooms as an empty object
        const drawingHistory = {};
        
        let mostRecentUserJoinTimestamp = 0;
        let mostRecentUser = '';
        
        let isFirstUser = false;
        
        let lastServerX, lastServerY;
        
        function setCookie(name, value, days) {
            const expires = new Date();
            expires.setTime(expires.getTime() + days * 24 * 60 * 60 * 1000);
            document.cookie = `${name}=${value};expires=${expires.toUTCString()};path=/`;
        }
        
        function getCookie(name) {
            const keyValue = document.cookie.match(`(^|;) ?${name}=([^;]*)(;|$)`);
            return keyValue ? keyValue[2] : null;
        }

        function joinRoom() {
            const roomCode = $('#roomCode').val().trim();
            if (roomCode) {
                // Redirect to the room-specific URL
                window.location.href = `/${roomCode}`;
            }
        }

        function handleKeyUp(event) {
            if (event.key === 'Enter') {
                joinRoom();
            }
        }

        // Check if there is a room code in the URL
        const roomCodeInUrl = window.location.pathname.slice(1);
        if (roomCodeInUrl) {
            // Room code is present, show chat content
            $('#content').show();
            $('#landing').hide();
            $('#toggleChatButton').hide();
            document.title = roomCodeInUrl;

            // Load username and color from cookies
            const savedUsername = getCookie('username');
            const savedColor = getCookie('color');

            if (savedUsername) {
                // Check if the saved username is "Guest"
                if (savedUsername === "Guest") {
                    // If the saved username is "Guest", set the input value to blank
                    $('#username').val("");
                } else {
                    // If the saved username is not "Guest", set the input value to the saved username
                    $('#username').val(savedUsername);
                }
            }

            if (savedColor) {
                $('#color').val(savedColor);
            }

            // Update settings with loaded values
            // updateSettings();
        } else {
            // Room code is not present, show landing page
            $('#landing').show();
            $('#content').hide();
            $("#canvas").hide();
        }
        // Enable message input and button after updating settings
        const enableMessageInput = () => {
            $('#m').prop('disabled', false);
            $('form button').prop('disabled', false);
        };
        
        // Function to handle restoring canvas data
        const restoreCanvas = () => {
            // Your logic for restoring canvas data goes here
            // For example, you might want to emit the 'restoreCanvas' event to the server
            // with the appropriate data, and handle it on the server-side
            socket.emit('restoreCanvas', { ctx });
        };

        const updateSettings = () => {
            username = $('#username').val() || 'Guest';
            color = $('#color').val() || '#ffffff';

            // Set cookies for username and color
            setCookie('username', username, 365);
            setCookie('color', color, 365);

            // Emit user information to the server
            socket.emit('join', { room, username, color });

            // Call restoreCanvas immediately after emitting the join event
            restoreCanvas();

            // Hide settings
            $('#settings').hide();
            $('#canvas').show();
            $('#toggleChatButton').show();
            
            $('#messages').width("400px");
            $('#messages').css('padding', '10px');
            
            // Check if the current user is the most recently-joined user
            if (isFirstUser) {
                // Show the public room toggle for the most recently-joined user
                $('#publicToggleLabel').show();
                $('#publicToggle').show();
            }
            else
            {
                $('#publicOrPrivateText').show();
                publicOrPrivateText.textContent = 'Public Room';
            }
            
            // Enable message input and button
            enableMessageInput();
        };

        const sendMessage = (messageType, data) => {
            // Include username and color in the message data
            socket.emit(messageType, { room, username, color, ...data });

            // Clear the input field
            $('#m').val('');
        };

        $('form').submit(function () {
            sendMessage('message', { message: $('#m').val().trim() });
            return false;
        });

        // Event listener for the Enter key press in the username input
        $('#username').on('keyup', function (event) {
            if (event.key === 'Enter') {
                updateSettings();
            }
        });

        socket.on('message', function (data) {
            // Display messages with usernames and colors
            const message = `<span style="color: ${data.color}">${data.username}:</span> ${data.message}`;
            appendMessage(message);
        });

        // Add this block to your existing script
        let canvas, ctx, drawing, lastX, lastY;

        $(document).ready(function () {
            // Get the canvas and its 2d context
            canvas = document.getElementById('canvas');
            ctx = canvas.getContext('2d');

            // Set canvas dimensions relative to the viewport
            canvas.width = window.innerWidth * 1.1; // 90% of the viewport width
            canvas.height = window.innerHeight * 1.1; // 90% of the viewport height
            
            $('#publicToggleLabel').hide();
            $('#publicToggle').hide();

            // Initialize drawing variables
            drawing = false;
            lastX = 0;
            lastY = 0;

            // Add mouse event listeners to the canvas
            canvas.addEventListener('mousedown', startDrawing);
            canvas.addEventListener('mousemove', draw);
            canvas.addEventListener('mouseup', stopDrawing);
            canvas.addEventListener('mouseout', stopDrawing);
            
            canvas.addEventListener('touchstart', handleTouchStart);
            canvas.addEventListener('touchmove', handleTouchMove);
            canvas.addEventListener('touchend', handleTouchEnd);
            
            toggleChat();
        });

        function startDrawing(e) {
            const rect = canvas.getBoundingClientRect();
            drawing = true;
            lastX = e.clientX - rect.left;
            lastY = e.clientY - rect.top;

            // Store the starting point of the drawing for the current user
            drawingHistory[username] = [{ x: lastX, y: lastY }];

            sendMessage('drawingStart', { startX: lastX, startY: lastY });
        }

        function draw(e) {
            if (!drawing) return;
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(lastX, lastY);
            ctx.lineTo(x, y);
            ctx.stroke();

            lastX = x;
            lastY = y;

            // Store the intermediate points of the drawing for the current user
            drawingHistory[username].push({ x, y });

            sendMessage('drawing', { x, y, color });
        }

        function stopDrawing() {
            if (!drawing) return;
            drawing = false;

            // Clear the drawing history for the current user when drawing stops
            delete drawingHistory[username];

            sendMessage('drawingEnd', {});
        }
        
        // Variables to store touch start coordinates
        let touchStartX, touchStartY;

        // Function to handle touch start
        function handleTouchStart(e) {
            e.preventDefault(); // Prevent default touch event behavior
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect(); // Define rect here
            lastX = touch.clientX - rect.left;
            lastY = touch.clientY - rect.top;

            ctx.beginPath();
            ctx.moveTo(lastX, lastY);

            // Emit drawing start to others in the room
            sendMessage('drawingStart', { startX: lastX, startY: lastY });
        }

        // Function to handle touch move
        function handleTouchMove(e) {
            e.preventDefault(); // Prevent default touch event behavior
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect(); // Define rect here
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;

            // Draw a line from the last position to the current position
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.lineTo(x, y);
            ctx.stroke();

            // Update the last position
            lastX = x;
            lastY = y;

            // Emit drawing data to others in the room
            sendMessage('drawing', { x, y, color });
        }

        // Function to handle touch end
        function handleTouchEnd(e) {
            e.preventDefault(); // Prevent default touch event behavior
            drawing = false;

            // Emit drawing end to others in the room
            sendMessage('drawingEnd', {});
        }
        
        // Function to clear drawing history when the canvas is cleared
        function clearCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Clear drawing history for all users
            for (const user in drawingHistory) {
                delete drawingHistory[user];
            }

            sendMessage('clearCanvas', {});
        }

        // Function to append messages and drawings to the messages container
        function appendMessage(message) {
            // Append the new message
            const newMessage = $('<li>').html(message);
            const messagesContainer = $('#messages');

            // Append the new message and remove the oldest if needed
            messagesContainer.append(newMessage);

            // Scroll messages up when a new message is added
            messagesContainer.scrollTop(messagesContainer.prop('scrollHeight'));
        }
        
        // Function to handle drawing from server data
        function drawFromServer(data) {
            const [x, y] = [data.x, data.y];

            // Draw a line from the last server-sent position to the current position
            ctx.strokeStyle = data.color;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(lastServerX, lastServerY); // Move to the last server-sent position
            ctx.lineTo(x, y); // Draw a line to the current position
            ctx.stroke();

            // Update the last server-sent position
            lastServerX = x;
            lastServerY = y;
        }

        // Socket event to receive drawing data from the server
        socket.on('drawing', function (data) {
            drawFromServer(data);
        });

        socket.on('drawingStart', function (data) {
            //[lastX, lastY] = [data.startX, data.startY];
            //ctx.beginPath();
            //ctx.moveTo(lastX, lastY);
            
            lastServerX = data.startX;
            lastServerY = data.startY;
        });

        /*
        socket.on('drawing', function (data) {
            const [x, y] = [data.x, data.y];

            // Draw a line from the last position to the current position
            ctx.strokeStyle = data.color;
            ctx.lineWidth = 2;
            ctx.lineTo(x, y);
            ctx.stroke();

            // Update the last position
            //[lastX, lastY] = [x, y];
        });
        */
        
        socket.on('drawingEnd', function () {
            //drawing = false;
        });

        socket.on('clearCanvas', function () {
            // Clear the canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        });

        socket.on('userJoin', function (data) {
            // Increment the user count for the joined room
            activeRooms[data.room] = (activeRooms[data.room] || 0) + 1;

            // Emit the updated user count to all clients in the room
            io.to(data.room).emit('activeUsersCount', { room: data.room, count: activeRooms[data.room] });

            // Store the timestamp of the most recent user join event
            const currentTime = new Date().getTime();
            if (currentTime > mostRecentUserJoinTimestamp) {
                mostRecentUserJoinTimestamp = currentTime;
                mostRecentUser = data.username;
            }

            // Check if there were previously no users in the room
            if (activeRooms[data.room] === 1) {
                isFirstUser = true;
                // Send a message to the chat box indicating that this is the first user
                io.to(data.room).emit('message', {
                    username: 'System',
                    color: '#ffffff',
                    message: `${data.username} is the first user in the room.`
                });
            }
        });
        
        socket.on('userLeave', function (data) {
            // Decrement the user count for the left room
            if (activeRooms[data.room] > 0) {
                activeRooms[data.room]--;

                // Emit the updated user count to all clients in the room
                io.to(data.room).emit('activeUsersCount', { room: data.room, count: activeRooms[data.room] });

                // Check if the leaving user is the first user
                if (data.username === mostRecentUser) {
                    // Find the new earliest join timestamp and corresponding username
                    let earliestJoinTimestamp = Infinity;
                    let newFirstUser = '';
                    for (const [user, joinTime] of Object.entries(activeUsers)) {
                        if (joinTime < earliestJoinTimestamp) {
                            earliestJoinTimestamp = joinTime;
                            newFirstUser = user;
                        }
                    }
                    // Update the first user's information
                    firstUserJoinTimestamp = earliestJoinTimestamp;
                    firstUser = newFirstUser;

                    // Print the updated result
                    console.log(`The first person to join the room is now: ${firstUser}`);
                }
            }

            // Check if there are no users left in the room
            if (activeRooms[data.room] === 0) {
                // Clear the first user information
                firstUserJoinTimestamp = 0;
                firstUser = '';

                // Print a message indicating that there are no users in the room
                console.log('No users left in the room.');
            }
        });
    
    // Add this block to your existing script
    socket.on('activeRooms', function (data) {
        activeRooms = data.activeRooms; // Update the local activeRooms variable.
        activeRoomsVar = activeRooms;
    });
        
        socket.on('connection', function (socket) {
            // Broadcast active user count to the new user
            socket.on('activeUsersCount', function (data) {
                io.to(socket.id).emit('activeUsersCount', { room: data.room, count: activeRooms[data.room] });
            });
        });

        // Function to get the list of active rooms
        function getActiveRooms() {
            const activeRoomList = Object.keys(activeRooms).filter((room) => activeRooms[room] > 0);
            return activeRoomList;
        }

        function joinRandomRoom() {
            // Get the list of active rooms
            const activeRoomList = activeRooms;

            // Check if there are active rooms
            if (activeRoomList.length > 0) {
                // Randomly select a room from the list
                const randomRoom = activeRoomList[Math.floor(Math.random() * activeRoomList.length)];

                // Debugging: Log the randomly selected room to the console
                console.log('Random Room:', randomRoom);

                // Redirect to the selected room-specific URL
                window.location.href = `/${randomRoom}`;
                
                // Emit the updated user count to all clients in the room
                io.to(data.room).emit('activeUsersCount', { room: data.room, count: activeRooms[data.room] });
            } else {
                // Debugging: Alert the current state of activeRooms
                alert("No active rooms available. Create or join a room manually.");
            }
        }
        
        //Function to save the canvas image
        const saveCanvasImage = () => {
            const canvas = document.getElementById('canvas');
            const dataUrl = canvas.toDataURL(); // Get the data URL of the canvas image
            const a = document.createElement('a');
            a.href = dataUrl;
            a.download = 'image.png';
            a.click();
        };
        
        function generateAndJoinRoom() {
            const generatedRoomCode = generateRandomRoomCode();
            window.location.href = `/${generatedRoomCode}`;
        }

        function generateRandomRoomCode() {
            const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
            const codeLength = 6; // Adjust the length of the generated room code if needed
            let roomCode = '';

            for (let i = 0; i < codeLength; i++) {
                const randomIndex = Math.floor(Math.random() * characters.length);
                roomCode += characters.charAt(randomIndex);
            }

            return roomCode;
        }
        
        socket.on('activeUsersCount', function (data) {
               // Update the active user count in the UI
               updateActiveUsersCount(data.count);
           });

        // Function to update the active user count in the UI
        function updateActiveUsersCount(count) {
            const activeUsersCountElement = $('#activeUsersCount');
            activeUsersCountElement.text(`Active Users: ${count}`);
        }
        
        function toggleChat() {
            const messages = document.getElementById('messages');
            const toggleChatButton = document.getElementById('toggleChatButton');

            if (messages.style.display === 'none' || messages.style.display === '') {
                messages.style.display = 'block';
                toggleChatButton.style.marginTop = '35vh';
                toggleChatButton.textContent = 'Close Chat'; // Change button text to "Close Chat"
            } else {
                messages.style.display = 'none';
                toggleChatButton.style.marginTop = '5vh';
                toggleChatButton.textContent = 'Open Chat'; // Change button text to "Open Chat"
            }
        }

        // Function to show chat content and toggle button
        function showChat() {
            const content = document.getElementById('content');
            const button = document.getElementById('toggleChatButton');

            $('#m').show();
                   
            //button.style.display = 'block'; // Show the toggle button
            button.textContent = 'Close Chat';
        }

        // Function to hide chat content and toggle button
        function hideChat() {
            const content = document.getElementById('content');
            const button = document.getElementById('toggleChatButton');

            $('#m').hide();
        }
        
        // Update the function to show public/private text instead of the toggle button
        function updatePublicOrPrivateText(isPublic) {
            const publicOrPrivateText = document.getElementById('publicOrPrivateText');
            if (isPublic) {
                publicOrPrivateText.textContent = 'Public Room'; // Display text for public room
            } else {
                publicOrPrivateText.textContent = 'Private Room'; // Display text for private room
            }
            publicOrPrivateText.style.display = 'block'; // Show the text
        }
    </script>
</body>
</html>
